---
title: 数据结构学习笔记
date: 2024-01-22 15:12:41
tags:
    - 数据结构
category: Math
---
### 前言

什么是数据结构？

> 数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系。

![](https://img-blog.csdnimg.cn/img_convert/adeadae0d0dea9cd9fa42852f5a6b6b2.png)

### 线性表

> 拿处理学生信息举一个例子，我们希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。

数组无法做到这么高级的功能，那么我们就需要定义一种更加高级的数据结构来做到，我们可以使用线性表（Linear List）

> 线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。

线性表一般需要包含以下功能：

- **初始化线性表：**将一个线性表进行初始化，得到一个全新的线性表。
- **获取指定位置上的元素：**直接获取线性表指定位置`i`上的元素。
- **获取元素的位置：**获取某个元素在线性表上的位置`i`。
- **插入元素：**在指定位置`i`上插入一个元素。
- **删除元素：**删除指定位置`i`上的一个元素。
- **获取长度：**返回线性表的长度。

也就是说，现在我们需要设计的是一种功能完善的表结构，它不像是数组那么低级，而是真正意义上的表：

实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现。他们分别是顺序表和链表。

### 链表

链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。

链表分为带头结点的链表和不带头结点的链表，戴头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据

![](https://img-blog.csdnimg.cn/img_convert/85dc3504e1bed27afad5564b368c918b.png)

而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。

**单链表的插入**

![](https://img-blog.csdnimg.cn/img_convert/cad7b56babe16ece8ee835c9ba893182.png)

我们可以先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点：

![](https://img-blog.csdnimg.cn/img_convert/184241a4c17a9c6468c8309994b89dcb.png)

接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点：

![](https://img-blog.csdnimg.cn/img_convert/d2cd8cd198ecfe17d3688d449caa0dc3.png)

这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上：

![](https://img-blog.csdnimg.cn/img_convert/6bc3bc7fa667b3f81c6668e127b75a40.png)

#### 双链表

通过链式存储，我们不用再像顺序表那样一次性申请一段连续的空间，而是只需要单独为结点申请内存空间，同时在插入和删除的速度上也比顺序表轻松。不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。

为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针。这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表）

![](https://pic.imgdb.cn/item/65afc6d3871b83018a845121.png)

#### 循环链表

接着我们再来简单认识一下另一种类型的链表，循环链表，这种链表实际上和前面我们讲的链表是一样的，但是它的最后一个结点，是与头结点相连的，双向链表和单向链表都可以做成这样的环形结构，我们这里以单链表为例：

![image-20220724134153904.png](https://s2.loli.net/2022/07/24/KZl4SJVYQ5cfv7b.png)

这种类型的链表实际上与普通链表的唯一区别就在于最后是否连接到头结点，因此循环链表支持从任意一个结点出发都可以到达任何的结点，而普通的链表则只能从头结点出发才能到达任意结点，同样也是为了更灵活而设计的。

**双链表插入操作**

接着是双向链表的插入操作，这就比单链表要麻烦一些了，我们先来分析一下：

![](https://pic.imgdb.cn/item/65afc9bd871b83018a915642.jpg)

首先我们需要考虑后继结点，当新的结点插入之后，新的结点的后继结点就是原本在此位置上的结点，所以我们可以先将待插入结点的后继指针指向此位置上的结点。

由于是双向链表，所以我们需要将原本在此位置上的结点的前驱指针指向新的结点：

![image-20220724130219180](https://pic.imgdb.cn/item/65afca46871b83018a93a805.png)

接着我们来处理一下前驱结点，首先将前驱结点的后继指针修改为新的结点：

![image-20220724130342232](https://pic.imgdb.cn/item/65afca53871b83018a93e083.png)

最后我们将新的结点的前驱指针指向前驱结点即可：

![image-20220724130442927](https://pic.imgdb.cn/item/65afca61871b83018a9420de.png)

**双链表删除操作**

无论是正向遍历还是反向遍历，都可以正常完成，相比单链表的灵活度肯定是更大的，我们接着来看删除操作，其实删除操作也是差不多的方式：

![image-20220724132636580](https://pic.imgdb.cn/item/65afcab0871b83018a9574e9.png)

我们只需将前驱结点和后继结点的指向修改即可：

![image-20220724132801105](https://pic.imgdb.cn/item/65afcaba871b83018a959c6d.png)

接着直接删除对应的结点即可：

![image-20220724132906001](https://pic.imgdb.cn/item/65afcac3871b83018a95c186.png) 